int CameraManager::GetPic()
{
  CameraSdkStatus status;
  HANDLE hBuf;
  BYTE* pbyBuffer;
  stImageInfo imageInfo;



  status = CameraSoftTrigger(hCamera_);
  if(status != CAMERA_STATUS_SUCCESS) {
    std::cout << "soft trigger failed" << std::endl;
    return -1;
  }
  // 获取raw image data 1000ms超时时间
  status = CameraGetRawImageBuffer(hCamera_, &hBuf, 1000);
  if (status != CAMERA_STATUS_SUCCESS) {
    std::cout << "CameraGetRawImageBuffer " << status << std::endl;
    return -1;
  }
  // 获取图像帧信息
  pbyBuffer = CameraGetImageInfo(hCamera_, hBuf, &imageInfo);
  // 申请RGB image buffer内存
  if (pRBGBuffer_ == NULL || imageInfo.iWidth * imageInfo.iHeight > dwRGBBufSize_) {
      if (pRBGBuffer_)
          delete []pRBGBuffer_;
      dwRGBBufSize_ = imageInfo.iWidth * imageInfo.iHeight;
      pRBGBuffer_ = new BYTE[dwRGBBufSize_];
  }

  //处理原始图像
  status = CameraGetOutImageBuffer(hCamera_, &imageInfo, pbyBuffer, pRBGBuffer_);
  CameraReleaseFrameHandle(hCamera_, hBuf);
  if (status != CAMERA_STATUS_SUCCESS) {
    std::cout << "handle picture fault " << status  << std::endl;
    return -1;
  }

  if (imageInfo.iWidth != dwWidth_ && imageInfo.iHeight != dwHeight_) {
    std::cout << "picture resolution inequality" << std::endl;
  }

  std::cout << "get a pic " << imageInfo.iWidth << "x" << imageInfo.iHeight << " " << imageInfo.TotalBytes << std::endl;
  return 0;
}
